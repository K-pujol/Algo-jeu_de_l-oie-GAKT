int D1 = 0;
int D2 = 0;
int nb_players=8;
int joueur_actif=nb_players-1;
int players_colors= int(360/(nb_players+1));
int[][] plateau = new int [64][2];
int taillecase= 30;
int plateau_y=taillecase/2;
boolean play=false;
int attente=0;
int unit = 10;
int count;
boolean victoire = false;
int joueur_victorieux = -1;
final int HOTEL=19;
final int LABYRINTHE=42;
final int TETEDEMORT=58;
final int OIES=9;
final int PRISON=52;
final int DEPART=0;
final int ARRIVEE=63;
final int PUITS=3;
final int POSITION=0;
final int ATTENTE=1;
final color BG = color (240, 224, 211);
Joueur[] joueurs = new Joueur[nb_players];



void settings() {
  size (taillecase*64, int(taillecase*(nb_players+1)));
}

void setup() {

  colorMode(HSB, 360, 100, 100);
  textSize(taillecase);
  rectMode(CENTER);
  background(BG);
  init_plateau();
  display_plateau();
  for (int i = 0; i < nb_players; i++) {
    int c = color((i + 1) * 360 / (nb_players + 1), 100, 100);
    joueurs[i] = new Joueur(0, 0, c);
    display_player(i);
  }
}

class Joueur {
  int position_joueur;
  int tour_attente;
  int couleur;

  float xActuel;
  float xCible;
  boolean enDeplacement = false;


  // Constructeur
  Joueur(int posX, int attenteX, int couleurX) {
    position_joueur = posX;
    tour_attente = attenteX;
    couleur = couleurX;
    xActuel = plateau[0][0];
    xCible = plateau[0][0];
  }
}



void draw() {
  init_plateau();
  display_plateau();

  if (play) {


    if (joueurs[joueur_actif].tour_attente ==0) {
      D1 = LancerDes();
      D2 = LancerDes();
      println("Joueur ", joueur_actif+1, " sur case ", joueurs[joueur_actif].position_joueur, " fait ", D1, "+", D2, "il atterit sur la case", (joueurs[joueur_actif].position_joueur + D1 + D2) );
      mouvement_player(D1, D2);
      cas_speciaux(joueur_actif, D1, D2);
    } else {
      println("Joueur ", joueur_actif+1, " passe son tour.");
      joueurs[joueur_actif].tour_attente--;
    }
    play=false;
  }

  for (int i = 0; i < nb_players; i++) {
    if (joueurs[i].enDeplacement) {
      joueurs[i].xActuel = lerp(joueurs[i].xActuel, joueurs[i].xCible, 0.05);
      if (abs(joueurs[i].xActuel - joueurs[i].xCible) < 1) {
        joueurs[i].xActuel = joueurs[i].xCible;
        joueurs[i].enDeplacement = false;

        if (joueurs[i].position_joueur == ARRIVEE && !victoire) {
          victoire = true;
          joueur_victorieux = i;
          println("Joueur ", i+1, " a atteint la case 63 et gagne la partie!");
        }
      }
    }
    display_player(i);
  }


  boolean allPlayersLost = true;
  for (int i = 0; i < nb_players; i++) {
    if (joueurs[i].tour_attente != -1 || joueurs[i].enDeplacement) {
      allPlayersLost = false;
      break;
    }
  }
  if (allPlayersLost) {
    lostgame();
  }
  if (victoire == true) {
    wingame();
  }
}

int check_case(int case_id) {
  int case_occuped= -1;
  for (int i=0; i<nb_players; i++) {
    if (i != joueur_actif) {
      if (joueurs[i].position_joueur==case_id) {
        case_occuped=i;
      }
    }
  }
  return case_occuped;
}

void cas_speciaux(int joueur_actif, int D1, int D2) {
  int pos_joueur = joueurs[joueur_actif].position_joueur;

  if (pos_joueur % OIES == 0 && pos_joueur != 0 && pos_joueur != ARRIVEE) {

    println("Joueur ", joueur_actif+1, " tombe sur une oie. Il avance à nouveau." );
    mouvement_player(D1, D2);
    cas_speciaux(joueur_actif, D1, D2);
  }

  if (pos_joueur==HOTEL) {
    int autre = check_case(pos_joueur);
    if (autre == -1 ) {
      joueurs[joueur_actif].tour_attente = 2;
      println("Joueur ", joueur_actif+1, " dort à l'hotel pour 2 tours. Il attend qu'on vienne le réveiller");
    } else {
      if (joueurs[autre].tour_attente != 0) {
        joueurs[autre].tour_attente = 0;
        println("Joueur ", joueur_actif+1, " libère le joueur ", autre+1, " de l'hotel");
      }
    }
  }

  if (pos_joueur == LABYRINTHE) {
    if (pos_joueur == LABYRINTHE) {
      joueurs[joueur_actif].position_joueur = 30; // Déplace le joueur à la case 30
      joueurs[joueur_actif].xCible = plateau[30][0]; // Met à jour la cible graphique
      joueurs[joueur_actif].enDeplacement = true; // Le joueur commence à se déplacer graphiquement
      println("Joueur ", joueur_actif + 1, " se perd dans le labyrinthe. Il retourne en case 30.");
    }
    int found_player = check_case(30);
    if (found_player != -1) {

      int temp = joueurs[joueur_actif].position_joueur;
      joueurs[joueur_actif].position_joueur = joueurs[found_player].position_joueur;
      joueurs[found_player].position_joueur = temp;


      joueurs[joueur_actif].xCible = plateau[joueurs[joueur_actif].position_joueur][0];
      joueurs[found_player].xCible = plateau[joueurs[found_player].position_joueur][0];

      joueurs[joueur_actif].enDeplacement = true;
      joueurs[found_player].enDeplacement = true;

      println("Joueur ", joueur_actif + 1, " mange le joueur ", found_player + 1, " et les positions sont échangées.");
    }
  }

  if (pos_joueur == TETEDEMORT) {
    joueurs[joueur_actif].position_joueur = DEPART; // Déplace le joueur à la case 0
    joueurs[joueur_actif].xCible = plateau[DEPART][0]; // Met à jour la cible graphique
    joueurs[joueur_actif].enDeplacement = true; // Le joueur commence à se déplacer graphiquement
    println("Joueur ", joueur_actif + 1, " est mort. Il recommence la partie.");
  }

  if (pos_joueur == PUITS) {
    int autre = check_case(pos_joueur);
    if (autre == -1) {
      joueurs[joueur_actif].tour_attente = -1;
      println("Joueur ", joueur_actif+1, " tombe dans le puits. Il attend qu'on vienne le libérer");
    } else {
      if (joueurs[autre].tour_attente == -1) {
        joueurs[autre].tour_attente = 0;
        println("Joueur ", joueur_actif+1, " libère le joueur ", autre+1, " du puits !");
      }
    }
  }

  if (pos_joueur == PRISON) {
    int autre = check_case(pos_joueur);
    if (autre == -1) {
      joueurs[joueur_actif].tour_attente = -1;
      println("Joueur ", joueur_actif+1, " est en prison. Il attend qu'on vienne le libérer");
    } else {
      // Libère l'autre joueur
      if (joueurs[autre].tour_attente == -1) {
        joueurs[autre].tour_attente = 0;
        println("Joueur ", joueur_actif+1, " libère le joueur ", autre+1, " de la prison !");
      }
    }
  }
}

void mouvement_player(int D1, int D2) {
  int future_case = joueurs[joueur_actif].position_joueur + D1 + D2;



  if (future_case > 63) {
    int ecart = future_case - 63;
    future_case = 63 - ecart;
    println("Joueur ", joueur_actif+1, " est allé trop loin. Il recule de ", ecart, " cases.");
  }

  if (future_case == 63) {
    joueurs[joueur_actif].position_joueur = 63;
    joueurs[joueur_actif].xCible = plateau[63][0];
    joueurs[joueur_actif].enDeplacement = true;
    return;
  }


  if (joueurs[joueur_actif].position_joueur==0 && future_case == 9) {
    if ((D1 == 6 && D2 == 3) || (D1 == 3 && D2 == 6)) {
      future_case = 26;
      mouvement_player(0, 26);
    }
    if ((D1 == 5 && D2 == 4) || (D1 == 4 && D2 == 5)) {
      future_case = 53;
      mouvement_player(0, 53);
    }
    if (D1+D2 == 6) {
      future_case = 12;
      mouvement_player(0, 12);
    }
  }
  
  int player_found = check_case(future_case);
  if (player_found >= 0) {

    int temp = joueurs[joueur_actif].position_joueur;
    joueurs[joueur_actif].position_joueur = joueurs[player_found].position_joueur;
    joueurs[player_found].position_joueur = temp;

    joueurs[joueur_actif].xCible = plateau[joueurs[joueur_actif].position_joueur][0];
    joueurs[player_found].xCible = plateau[joueurs[player_found].position_joueur][0];

    joueurs[joueur_actif].enDeplacement = true;
    joueurs[player_found].enDeplacement = true;

    println("Joueur ", joueur_actif+1, " mange le joueur ", player_found+1, " et les positions sont échangées.");
  } else
  {
    joueurs[joueur_actif].position_joueur = future_case;
    joueurs[joueur_actif].xCible = plateau[future_case][0];
    joueurs[joueur_actif].enDeplacement = true;
  }
}

void display_player(int joueur)
{
  int cellule = joueurs[joueur].position_joueur;
  fill(BG);
  noStroke();
  rect(32 * taillecase, plateau_y* (joueur + 2) * 1.4, taillecase * 64, (taillecase * 1.2)/2);
  
  stroke(0);
  fill(joueurs[joueur].couleur);
  ellipse(joueurs[joueur].xActuel, plateau_y * (joueur + 2) * 1.4, taillecase / 2, taillecase / 2);
  
  fill(0);
  textAlign(CENTER, CENTER);
  textSize(taillecase * 0.4);
  text(joueur + 1, joueurs[joueur].xActuel, plateau_y * (joueur + 2) * 1.4);
  
  textSize(taillecase * 1);
  text(cellule, plateau[cellule][0], plateau_y);
}

void display_case(int i) {
  fill (#EDEDE8);
  switch(i) {
  case PUITS:
    fill(#61ADFC);
    break;
  case PRISON:
    fill(#F07816);
    break;
  case HOTEL:
    fill(#E71CE8);
    break;
  case LABYRINTHE:
    fill(#865E08);
    break;
  case TETEDEMORT:
    fill(#5A5753);
    break;
  case 9:
  case 18:
  case 27:
  case 36:
  case 45:
  case 54:
    fill(#F5EE11);
    break;
  case 0:
    fill(#2DFF00);
    break;
  case 63:
    fill(#21860B);
    break;
  }
  rect (plateau[i][0], plateau_y, taillecase, taillecase);
  textAlign(CENTER, CENTER);
  fill(0);
  text(i, plateau[i][0], plateau_y);
}
void display_plateau() {
  for (int i = 0; i < 64; i++) {
    display_case(i);
  }
}


void init_plateau() {
  for (int i=0; plateau.length>i; i++) {
    plateau[i][0]=i*taillecase+taillecase/2;
    switch(i) {
    case DEPART:
      plateau[i][1]=DEPART;
      break;
    case PUITS:
      plateau[i][1]=PUITS;
      break;
    case OIES:
    case 18:
    case 27:
    case 36:
    case 45:
      plateau[i][1]=OIES;
      break;
    case HOTEL:
      plateau[i][1]=HOTEL;
      break;
    case LABYRINTHE:
      plateau[i][1]=LABYRINTHE;
      break;
    case PRISON:
      plateau[i][1]=PRISON;
      break;
    case TETEDEMORT:
      plateau[i][1]=TETEDEMORT;
      break;
    case ARRIVEE:
      plateau[i][1]=ARRIVEE;
      break;
    }
  }
}


int LancerDes() {

  return int(random(6)+1);
}

void wingame() {
  println("c'est gagné pour le joueur ", joueur_actif+1);
  victoire = true;
  joueur_victorieux = joueur_actif;
  noLoop();
}



void lostgame() {
  println("Tout le monde est bloqué, c'est perdu. Vous mourrez de vieillesse");
  noLoop();
}

void mouseClicked() {
  play = true;
  joueur_actif++;
  if (joueur_actif==nb_players) {
    joueur_actif=0;
  }
}
